# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

squareRootSymmetric <- function(M) {
    .Call('RDeco_squareRootSymmetric', PACKAGE = 'RDeco', M)
}

standardizeVector <- function(V) {
    .Call('RDeco_standardizeVector', PACKAGE = 'RDeco', V)
}

standardizeMatrix <- function(M) {
    .Call('RDeco_standardizeMatrix', PACKAGE = 'RDeco', M)
}

tMatrix <- function(M) {
    .Call('RDeco_tMatrix', PACKAGE = 'RDeco', M)
}

mulMatrices <- function(A, B) {
    .Call('RDeco_mulMatrices', PACKAGE = 'RDeco', A, B)
}

invSymmMatrix <- function(M) {
    .Call('RDeco_invSymmMatrix', PACKAGE = 'RDeco', M)
}

DECO_LASSO_C <- function(Y, X, p, n, lambda, r, ncores = 1L, intercept = TRUE) {
    .Call('RDeco_DECO_LASSO_C', PACKAGE = 'RDeco', Y, X, p, n, lambda, r, ncores, intercept)
}

#' DECO Parallelized Algorithm (Pure C++)
#'
#' This implements the algorithm DECO which was introduced in "DECOrrelated feature space partitioning
#' for distributed sparse regression" by Wang, Dunson, and Leng (2016). It assumes that we take the lasso to be the penalized
#' regression scehme.
#'
#' @param Y gives the nx1 vector of observations we wish to approximate with a linear model of type Y = Xb + e.
#' @param X gives the nxp matrix of regressors, each column corresponding to a different regressor.
#' @param p is the column dimension of X [equivalently, p is the number of regressor variables].
#' @param n is the row dimension of X (and Y) [equivalently, n is the number of observations/individuals].
#' @param m is the number of groups/blocks you wish to split X into, denoted X(i) for 1 <= i <= m.
#' @param lambda gives the (fixed) penalty magnitude in the LASSO fit of the algorithm.
#' @param ncores determines the number of threads used on each machine to parallelize computation.
#' @param r_1 is a tweaking parameter for making the inverse more robust (as we take inverse of XX + r_1*I).
#' @param r_2 is a tweaking parameter for making the inverse more robust (as we take inverse of X_MX_M + r_2*I).
#' @param intercept determines whether to include an intercept in the model or not.
#' @param refinement determines whether to include the refinement step (Stage 3 of the algorithm).
#' @param parallel_glmnet determines whether a parallel version of the Lasso coefficients should be used.
#' This parameter is ignored when \code{glmnet} is set to \code{FALSE} (see details).
#' @param glmnet determines whether \code{glmnet} function form \code{glmnet} R package should be used to compute the Lasso coefficients.
#' See details for further information. If set to \code{FALSE}, C++ implementation of coordinate descent algorithm is used.
#' @param precision determines the precision used in the coordinate descent algorithm. It is ignored when
#' \code{glmnet} is set to \code{TRUE}.
#' @param max_iter determines the maximum number of iterations used in the coordinate descent algorithm.
#' It is ignored when \code{glmnet} is set to \code{TRUE}.
#' @details This function is a C++ implementation of \code{DECO_LASSO_R} and \code{DECO_LASSO_MIX} functions.
#' Due to the fact that it is entirely written in C++ it runs faster than the corresponding R implementations for sufficiently large matrices.
#'
#' Two functions can be used to compute Lasso coefficients: \code{glmnet} R function (\code{glmnet = TRUE}).
#' and coordinate descent algorithm (\code{glmnet = FALSE}). \code{glmnet} R function is generally faster, but more memory is
#' required to pass the input argumentd from C++ to R and back. When \code{parallel_glmnet = TRUE} an R parallelized
#' version of \code{glmnet} is used. Note however that for small datasets this could lead to slower run times, due to the
#' communication between C++ and R.
#'
#' Descent coordinate algorithm is always run in a parallel way (using \code{ncores} threads).
#'
#' @return An estimate of the coefficients b.
#' @author Samuel Davenport, Jack Carter, Giulio Morina, Jeremias Knoblauch
#' @export
DECO_LASSO_C_PARALLEL <- function(Y, X, p, n, m, lambda, r_1, r_2 = 0.01, ncores = 1L, intercept = TRUE, refinement = TRUE, glmnet = TRUE, parallel_glmnet = FALSE, precision = 0.0000001, max_iter = 100000L) {
    .Call('RDeco_DECO_LASSO_C_PARALLEL', PACKAGE = 'RDeco', Y, X, p, n, m, lambda, r_1, r_2, ncores, intercept, refinement, glmnet, parallel_glmnet, precision, max_iter)
}

