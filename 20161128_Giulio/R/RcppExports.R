# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Square root of a symmetric matrix
#'
#' @param M a symmetric matrix
#' @return A matrix C which is the square root matrix of M (i.e. C*C=M)
#' @author Samuel Davenport, Jack Carter, Giulio Morina, Jeremias Knoblauch
#' @details To compute the square root of the matrix, \code{sqrtmat_sympd} function of Armadillo library is used.
#' @note This function is about 100 times faster than R function \code{sqrtm} (contained in expm package).
#'
#' Note that no check is done to test if the matrix M is actually symmetric.
#' @examples
#' require(expm)
#' require(rbenchmark)
#' A <- matrix(rnorm(10000,mean=10,sd=5),nrow=100)
#' A_symm <- A%*%t(A)
#' benchmark(sqrtm(A_symm),squareRootSymmetric(A_symm), order='relative')
#'
#' @export
squareRootSymmetric <- function(M) {
    .Call('RDeco_squareRootSymmetric', PACKAGE = 'RDeco', M)
}

#' Standardize a vector
#'
#' @param V a vector
#' @return Returns a vector with mean equal to 0.
#' @author Samuel Davenport, Jack Carter, Giulio Morina, Jeremias Knoblauch
#' @details To compute the standardized vector, each of its entries is subtracted with the vector's mean.
#' @note In general, this function does not return a vector with variance equal to 1.
#'
#' This function is about 2x slower than directly computing \code{v-mean(v)}, but it is faster than doing
#' \code{scale(v,scale=FALSE)}
#' @examples
#' require(rbenchmark)
#' v <- 1:5000000
#' benchmark({v-mean(v)},standardizeVector(v),scale(v,scale=FALSE), order='relative')
#'
#' @export
standardizeVector <- function(V) {
    .Call('RDeco_standardizeVector', PACKAGE = 'RDeco', V)
}

#' Standardize a matrix so that its mean is equal to 0
#'
#' @param M a matrix
#' @return A matrix with mean 0
#' @details The matrix is standardized by subtracting each column with the mean of that column.
#' @note In general, this function does not return a matrix with variance equal to 1.
#'
#' This function is about 2.5x times faster than doing \code{scale(M,scale=FALSE)}.
#' @examples
#' require(rbenchmark)
#' M <- matrix(rnorm(1000*5000,10,5), nrow=1000)
#' benchmark(scale(M,scale=FALSE),standardizeMatrix(M), order='relative')
#'
#' @export
standardizeMatrix <- function(M) {
    .Call('RDeco_standardizeMatrix', PACKAGE = 'RDeco', M)
}

#' Transpose of a matrix
#'
#' @param M a matrix
#' @return Its transpose
#' @details To compute the transpose matrix, Armadillo library is used.
#' @note This function is about 4 times slower than R function \code{t}.
#' @examples
#' require(rbenchmark)
#' benchmark(t(M),tMatrix(M),order='relative')
#'
#' @export
tMatrix <- function(M) {
    .Call('RDeco_tMatrix', PACKAGE = 'RDeco', M)
}

#' Multiply two matrices
#'
#' @param A a matrix
#' @param B a matrix whose size is compatible with the size of A
#' @return The matrix product A*B.
#' @details To compute such product, Armadillo library is used.
#' @note This function takes about the same speed as R matrix multiplication.
#' @examples
#' require(rbenchmark)
#' A <- matrix(rnorm(1000*500,10,5), nrow=1000, ncol=500)
#' B <- matrix(rnorm(1000*500,10,5), nrow=500, ncol=1000)
#' benchmark(A%*%B,mulMatrices(A,B),order='relative')
#'
#' @export
mulMatrices <- function(A, B) {
    .Call('RDeco_mulMatrices', PACKAGE = 'RDeco', A, B)
}

#' Inverse of a matrix
#'
#' @param M a symmetric quadratic matrix
#' @return The inverse of the matrix
#' @details To compute the square root of the matrix, \code{inv_sympd} function of Armadillo library is used.
#' @note This function is about 2.5x times faster than R function \code{solve}.
#'
#' Note that no check is done to test if the matrix M is actually symmetric.
#' @examples
#' require(rbenchmark)
#' M <- matrix(rnorm(1000^2,10,5), nrow=1000)
#' M_symm <- M%*%t(M)
#' benchmark(solve(M_symm),invSymmMatrix(M_symm),order='relative')
#'
#' @export
invSymmMatrix <- function(M) {
    .Call('RDeco_invSymmMatrix', PACKAGE = 'RDeco', M)
}

#' DECO Parallelized Algorithm (Pure C)
#'
#' This function is deprecated. Use \code{DECO_LASSO_C_PARALLEL} function.
#'
#' @details This function is equivalent to \code{DECO_LASSO_C_PARALLEL} function when fixing \code{m=1, ncores=1}.
#'
#' @export
DECO_LASSO_C <- function(Y, X, p, n, lambda, r, ncores = 1L, intercept = TRUE) {
    .Call('RDeco_DECO_LASSO_C', PACKAGE = 'RDeco', Y, X, p, n, lambda, r, ncores, intercept)
}

DECO_LASSO_C_PARALLEL <- function(Y, X, p, n, m, lambda, r_1, ncores = 1L, intercept = TRUE, refinement = TRUE, parallel_lasso = FALSE) {
    .Call('RDeco_DECO_LASSO_C_PARALLEL', PACKAGE = 'RDeco', Y, X, p, n, m, lambda, r_1, ncores, intercept, refinement, parallel_lasso)
}

