---
title: "RDeco Package"
author: Jack Carter, Samuel Davenport, Jeremias Knoblauch, Giulio Morina
output: pdf_document
header-includes:
   - \usepackage{amssymb}
---

```{r setup, echo=FALSE, message=FALSE}
require(RDeco)
require(rbenchmark)
```

## DECO Algorithm

DECO Algorithm provides a way to compute Lasso regression coefficients in a parallel and distributed way when $p \gg n$, where $p$ is the number of covariates and $n$ is the number of observations. The algorithm is based on splitting the $n \times p$ matrix $X$ vertically in $m$ submatrices. 

The theoretical fundation behind the algorithm can be found in "DECOrrelated feature space partitioning for distributed sparse regression" papaer by  Wang, Dunson, and Leng (2016).

## RDeco package

\texttt{RDeco} package provides 4 different implementations of the DECO algorithm:
\begin{itemize}
\item \texttt{DECO\char`_LASSO\char`_R}: a pure R implementation.
\item \texttt{DECO\char`_LASSO\char`_MIX}: a mix of R and C++ code.
\item \texttt{DECO\char`_LASSO\char`_C\char`_PARALLEL}: a pure C++ code.
\item \texttt{DECO\char`_LASSO\char`_R\char`_CLUSTER}: a pure R implementation for splitting the work load on different machines (still not stable).
\end{itemize}

All four functions currently only accept a fixed penalization parameter $\lambda$ and do not implement an automatic way to tune it. 

Given the same dataset and same parameters, the four functions all return the same result:

```{r data, eval=TRUE}
#Generating a simulated dataset
set.seed(100)
n<-5
p<-17
m<-4
sigma<-1
lambda<-0.03
r<-0.01
X<-matrix(rnorm(n*p, sd=1), nrow=n)
eps<-rnorm(n, mean = 0, sd = sigma)
activeCoefs<-sample(c(0,1),p, prob=c(0.5, 0.1), replace=TRUE)  ##get coefficients that impact Y
coefs<-activeCoefs*1
Y<-X%*%coefs + eps
ncores <- 8
clust <- makePSOCKcluster(c("greywagtail",
                             "greyheron",
                             "greypartridge",
                             "greyplover"))
for (refinement in c(FALSE,TRUE)) {
  res<-DECO_LASSO_R(Y, X, p=p, n=n, m=m, lambda=lambda, r_1=r,r_2=0.001, ncores = ncores, refinement = refinement)
  res_mix<-DECO_LASSO_MIX(Y, X, p=p, n=n, m=m, lambda=lambda, r_1=r,r_2=0.001, ncores = ncores, refinement = refinement)
  res_C<-as.vector(t(DECO_LASSO_C_PARALLEL(Y, X, p=p, n=n, m=m, lambda=lambda, r_1=r,r_2=0.001, ncores = ncores, refinement = refinement)))
  res_cluster <- DECO_LASSO_R_CLUSTER(Y, X, p=p, n=n, lambda=lambda, r_1=r, r_2=0.001, clust=clust, ncores=ncores, refinement = refinement)
  if(all.equal(res,res_mix) == TRUE && all.equal(res,res_C) == TRUE && all.equal(res_C,res_cluster) == TRUE) {
    print("All functions return the same result!")
  } else {
    print("NOT all functions return the same result...")
  }
}
stopCluster(clust)

```

Since \texttt{DECO\char`_LASSO\char`_C\char`_PARALLEL} function is entirely written in C++, it is faster than both \texttt{DECO\char`_LASSO\char`_MIX} and \texttt{DECO\char`_LASSO\char`_R}.

## Speed comparison

```{r data, eval=FALSE}
set.seed(100)
n<-5
p<-17
m<-4
sigma<-1
lambda<-0.03
r<-0.01
X<-matrix(rnorm(n*p, sd=1), nrow=n)
eps<-rnorm(n, mean = 0, sd = sigma)
activeCoefs<-sample(c(0,1),p, prob=c(0.5, 0.1), replace=TRUE)  ##get coefficients that impact Y
coefs<-activeCoefs*1
Y<-X%*%coefs + eps
ncores <- 8

for (refinement in c(FALSE,TRUE)) {
  res<-DECO_LASSO_R(Y, X, p=p, n=n, m=m, lambda=lambda, r_1=r,r_2=0.001, ncores = ncores, refinement = refinement)
  res_mix<-DECO_LASSO_MIX(Y, X, p=p, n=n, m=m, lambda=lambda, r_1=r,r_2=0.001, ncores = ncores, refinement = refinement)
  res_C<-as.vector(t(DECO_LASSO_C_PARALLEL(Y, X, p=p, n=n, m=m, lambda=lambda, r_1=r,r_2=0.001, ncores = ncores, refinement = refinement)))
  res_C_parallelLasso <- as.vector(t(DECO_LASSO_C_PARALLEL(Y, X, p=p, n=n, m=m, lambda=lambda, r_1=r,r_2=0.001, ncores = ncores, refinement = refinement, parallel_glmnet = TRUE)))
  res_C_gradientdescent <- as.vector(t(DECO_LASSO_C_PARALLEL(Y, X, p=p, n=n, m=m, lambda=lambda, r_1=r,r_2=0.001, ncores = ncores, refinement = refinement, glmnet = FALSE)))
  if(all.equal(res,res_mix) == TRUE && all.equal(res,res_C) == TRUE && all.equal(res_C,res_C_parallelLasso) == TRUE) {
    print("All functions return the same result!")
  } else {
    print("NOT all functions return the same result...")
  }
  print(benchmark(DECO_LASSO_R(Y, X, p=p, n=n, m=m, lambda=lambda, r_1=r, ncores = ncores, refinement = refinement),
            DECO_LASSO_MIX(Y, X, p=p, n=n, m=m, lambda=lambda, r_1=r, ncores = ncores, refinement = refinement),
            DECO_LASSO_C_PARALLEL(Y, X, p=p, n=n, m=m, lambda=lambda, r_1=r, ncores = ncores, refinement = refinement),
            DECO_LASSO_C_PARALLEL(Y, X, p=p, n=n, m=m, lambda=lambda, r_1=r, ncores = ncores, refinement = refinement, parallel_glmnet = TRUE),
            DECO_LASSO_C_PARALLEL(Y, X, p=p, n=n, m=m, lambda=lambda, r_1=r, ncores = ncores, refinement = refinement, glmnet = FALSE),
            replications = 10, order="relative"))

}


#Cluster
clust <- makePSOCKcluster(c("greywagtail",
                             "greyheron",
                             "greypartridge",
                             "greyplover"))
for (refinement in c(FALSE,TRUE)) {
  res_cluster <- DECO_LASSO_R_CLUSTER(Y, X, p=p, n=n, lambda=lambda, r_1=r, clust=clust, ncores=ncores, refinement = refinement)
   res<-DECO_LASSO_R(Y, X, p=p, n=n, m=m, lambda=lambda, r_1=r, ncores = ncores, refinement = refinement)
   if(all.equal(res_cluster,res) == TRUE ) {
    print("All functions return the same result!")
  } else {
    print("NOT all functions return the same result...")
  }
}
stopCluster(clust)

#Bigger dataset
n<-1000
p<-10000
m<-8
X<-matrix(rnorm(n*p, sd=1), nrow=n)
eps<-rnorm(n, mean = 0, sd = sigma)
activeCoefs<-sample(c(0,1),p, prob=c(0.9, 0.1), replace=TRUE)  ##get coefficients that impact Y
coefs<-activeCoefs*1
Y<-X%*%coefs + eps
for (refinement in c(FALSE,TRUE)) {
  print(benchmark(DECO_LASSO_C_PARALLEL(Y, X, p=p, n=n, m=m, lambda=lambda, r_1=r, ncores = ncores, refinement = refinement),
              DECO_LASSO_C_PARALLEL(Y, X, p=p, n=n, m=m, lambda=lambda, r_1=r, ncores = ncores, refinement = refinement, parallel_glmnet = TRUE),
              replications = 5, order="relative"))
}

```

